/*
 * cudadeblend.cu
 *
 *  Created on: 9 Jan, 2013
 *      Author: zhao
 */
#include <stdio.h>
#include <cuda.h>
#include <limits.h>
#include <cudpp.h>
#include <iostream>
#include <helper_cuda.h>
#include "cudatypes.h"

float	*d_multiThreshArray;
//for the whole image label of lower threshold
int		*d_rootLabelArray;

//store the deb result for compact and sort(should be moved to local var)
//unsigned int	**d_compactedDebLabelArray;
//unsigned int	**d_compactedDebIndexArray;
//float			**d_compactedDebPixelArray;
//float			**d_compactedDebCdPixelArray;
//unsigned int	**d_segmentDebMask;
//unsigned int	**d_compactedDebParentLabel;

unsigned int	**d_debPixelCountArray;
unsigned int	**d_debXminArray;
unsigned int	**d_debXmaxArray;
unsigned int	**d_debYminArray;
unsigned int	**d_debYmaxArray;
float			**d_debFdpeakArray;
float			**d_debDpeakArray;
float			**d_debFdfluxArray;
float			**d_debDthresh;
short			**d_debFlagArray;
short			**d_debOk;
unsigned int	**d_debParentLabel;

unsigned int	**d_finalDebLabelArray;
unsigned int	**d_finalDebPixelIndexArray;
unsigned int	**d_finalDebObjIndexArray;

size_t			*h_finalValidObj;
size_t			*h_finalValidPix;
//short* d_son;
//short* d_ok;
///////////////////////////

void compact_and_sort1(size_t numPixAboveThresh, int level);
size_t pre_analyse1(size_t compactedArraysize,
		size_t deb_maxarea,
		size_t* numValidObj,
		int level);
void cut_branch(int level, double mincount);


__global__ void segmentMaskInitKernel(unsigned int* d_compactedLabelArray,
		unsigned int* d_segmentMask, unsigned int numElements);
__global__ void getPixelFromIndexKernel(unsigned int* d_indexArray,
		float* d_inpixelArray, float* d_outpixelArray, size_t numElements);
__global__ void pixelCountMaskInitKernel(unsigned int* d_pixelCountMask,
		size_t numElements);
__global__ void xyposFromIndexKernel(unsigned int* d_indexArray,
		unsigned int* d_xposSegment,
		unsigned int* d_yposSegment,
		size_t numElements,
		int width);
__global__ void segmentmask_prune_kernel(
		unsigned int* d_compactedLabelArray,
		unsigned int* d_segmentEndMask,
		unsigned int* d_pixelCountSegment,
		size_t numElements,
		size_t ext_minarea);
__global__ void checkTruncKernel(unsigned int* d_xminArray,
		unsigned int* d_xmaxArray,
		unsigned int* d_yminArray,
		unsigned int* d_ymaxArray,
		short* d_flagArray,
		unsigned int h_numValidObj,
		unsigned int maxwidth,
		unsigned int maxheight);

__global__ void okInit_kernel(short *d_ok, unsigned int h_numValidObj);

__global__ void getLabelFromIndexKernel(unsigned int* d_indexArray,
		int* d_labelArrayIn,
		unsigned int* d_labelArrayOut,
		size_t numElements);

void checkcudppSuccess(CUDPPResult res, char* msg);

//////////////////////////////////////////////////////////
__global__ void rootLabelInitKernel(int* d_rootLabelArray,
		unsigned int* d_finalCompactedLabelArray,
		unsigned int* d_finalCompactedIndexArray,
		size_t numValidPix) {

	const int tid_x = blockDim.x * blockIdx.x + threadIdx.x;
	const int tid_y = blockDim.y * blockIdx.y + threadIdx.y;
	const int tid = tid_y * (gridDim.x * blockDim.x) + tid_x;

	if(tid < numValidPix) {
		d_rootLabelArray[d_finalCompactedIndexArray[tid]]
		                    = d_finalCompactedLabelArray[tid];
	}
}

__global__ void childLabelInitKernel(int* d_childLabelArray,
		unsigned int* d_finalCompactedDebLabelArray,
		unsigned int* d_finalCompactedDebIndexArray,
		size_t numValidPix) {

	const int tid = blockDim.x * blockIdx.x + threadIdx.x;

	if (tid == 0)
		d_childLabelArray[d_finalCompactedDebIndexArray[0]] =
				d_finalCompactedDebLabelArray[0];

	else if (tid < numValidPix) {
		if (d_finalCompactedDebLabelArray[tid] >
				d_finalCompactedDebLabelArray[tid - 1])
			d_childLabelArray[d_finalCompactedDebIndexArray[tid]] =
					d_finalCompactedDebLabelArray[tid];
	}
}

__global__ void getChildLabelKernel(int* d_sonArray,
		unsigned int* d_finalCompactedDebLabelArray,
		unsigned int* d_finalCompactedDebIndexArray,
		int* d_parentLabelArray,
		size_t finalValidPix) {

	const int tid = blockDim.x * blockIdx.x + threadIdx.x;

	if (tid == 0)
		d_sonArray[d_finalCompactedDebIndexArray[0]] =
				d_finalCompactedDebLabelArray[0];

	else if (tid < finalValidPix) {
		if (d_finalCompactedDebLabelArray[tid] >
				d_finalCompactedDebLabelArray[tid - 1])
			d_sonArray[d_finalCompactedDebIndexArray[tid]] =
					d_finalCompactedDebLabelArray[tid];
	}

}

__global__ void computeMultiThreshKernel(float* _d_multiThreshArray,
		float*	_d_fdpeakArray,
		float _base_thresh,
		int _deblend_nthresh,
		size_t numValidObj) {

	const int tid = blockDim.x * blockIdx.x + threadIdx.x;

	if(tid >= numValidObj)
		return;

	for(int i=1; i<_deblend_nthresh; i++) {
		_d_multiThreshArray[numValidObj * (i-1) + tid] =
				_base_thresh * pow((float)(_d_fdpeakArray[tid] / _base_thresh),(float)i/_deblend_nthresh);

		//debobjlist.dthresh = dthresh0 * pow(dthresh/dthresh0,(double)k/xn);
	}
}

__global__ void testIndexValid_kernel(unsigned int* indexArray,
		int* rootLabelArray,
		int num) {

	const int tid = blockDim.x * blockIdx.x + threadIdx.x;
	if(tid < num) {
		int id = indexArray[tid];
		int label = rootLabelArray[id];
		if(label < 0)
			printf("error!!!\t\n");
	}
}

__global__ void preInit_kernel(unsigned int *d_compactedIndexArray,
		int *d_labelArray,
		int *d_equivArray,
		int numValidPix) {

	const int tid = blockDim.x * blockIdx.x + threadIdx.x;

	if(tid < numValidPix) {

		int id = d_compactedIndexArray[tid];
		d_labelArray[id] = -1;
		d_equivArray[id] = -1;
	}
}

//n=31
//deblend_nthresh 32
//kernel shape: 4096 blocks, 32x32 threads per block
//0.105s
__global__ void deblendInit_kernel(float *d_cdPixArray,
		int *d_labelArray,
		int *d_equivArray,
		unsigned int *d_compactMask,
		unsigned int *d_compactedIndexArray,
		int *d_rootLabelArray,
		float* 	d_multiThreshArray,
		int numValidObj,
		int numValidPix,
		int n) {

	const int tid = blockDim.x * blockIdx.x + threadIdx.x;

	if(tid < numValidPix) {

		int id = d_compactedIndexArray[tid];
		int rootlabel = d_rootLabelArray[id];

		//parent label: 1,2,....
		//float thresh = d_multiThreshArray[(deblend_nthresh-1)*(rootlabel-1)+(n-1)];
		float thresh = d_multiThreshArray[(n-1)*numValidObj+ rootlabel-1];

		if(d_cdPixArray[id] >= thresh)
		{
			d_labelArray[id] = id;
			d_equivArray[id] = id;
			d_compactMask[tid]= 1;
		}
		else
		{
			d_labelArray[id] = -1;
			d_equivArray[id] = -1;
			d_compactMask[tid]= 0;
		}
	}
	//if(n==11 && tid < 1000)
	//	printf("%f\n", d_multiThreshArray[tid]);
}

//n < 31
__global__ void multiThreshLabelInitByChildKernel(float* d_cdPixArray,
		int* d_labelArray,
		int* d_equivArray,
		unsigned int* d_compactedIndexArray,
		unsigned int* d_compactedLabelArray,
		float* 	d_multiThreshArray,
		int numValidObj,
		int numValidPix,
		int n) {

	const int tid = blockDim.x * blockIdx.x + threadIdx.x;

	if(tid >= numValidPix)
		return;

	int id = d_compactedIndexArray[tid];
	int rootlabel = d_compactedLabelArray[tid];

	//child thresh label is not null
	if(d_labelArray[id] >= 0)
		return;

	//if(rootlabel <= -1)
	//	return;

	//parent label: 1,2,....
	//float thresh = d_multiThreshArray[(deblend_nthresh-1)*(rootlabel-1)+(n-1)];
	float thresh = d_multiThreshArray[(n-1)*numValidObj+ rootlabel-1];
	if(d_cdPixArray[id] >= thresh)
	{
		d_labelArray[id] = id;
		d_equivArray[id] = id;
	}
}

__global__ void debcompactMaskInitKernel(int* d_labelArray,
		unsigned int* d_compactMask,
		int numValidPix) {

	const int tid = blockDim.x * blockIdx.x + threadIdx.x;

	if(tid < numValidPix) {

		if (d_labelArray[tid] == -1)
			d_compactMask[tid] = 0;
		else
			d_compactMask[tid] = 1;
	}
}

__global__ void scanKernel1(int* d_labelArray,
		int* d_equivArray,
		unsigned int* d_compactedIndexArray,
		int numValidPix,
		int width,
		int height,
		int* update) {

	const int tid = blockDim.x * blockIdx.x + threadIdx.x;

	if(tid >= numValidPix)
		return;

	int id = d_compactedIndexArray[tid];

	int neighbors[8];
	int label1 = d_labelArray[id];
	int label2 = INT_MAX;
	if (label1 == -1)
		return;

	int id_x = id % width;
	int id_y = id / width;

	//the edge labels are  considered
	if (id_y > 0) {
		if (id_x > 0)
			neighbors[0] = d_labelArray[(id_y - 1) * width + (id_x - 1)];
		else
			neighbors[0] = -1;

		neighbors[1] = d_labelArray[(id_y - 1) * width + (id_x)];

		if (id_x < width - 1)
			neighbors[2] = d_labelArray[(id_y - 1) * width + (id_x + 1)];
		else
			neighbors[2] = -1;

	} else {
		neighbors[0] = -1;
		neighbors[1] = -1;
		neighbors[2] = -1;
	}

	if (id_x > 0)
		neighbors[3] = d_labelArray[(id_y) * width + (id_x - 1)];
	else
		neighbors[3] = -1;

	if (id_x < width - 1)
		neighbors[4] = d_labelArray[(id_y) * width + (id_x + 1)];
	else
		neighbors[4] = -1;

	if (id_y < (height - 1)) {
		if (id_x > 0)
			neighbors[5] = d_labelArray[(id_y + 1) * width + (id_x - 1)];
		else
			neighbors[5] = -1;

		neighbors[6] = d_labelArray[(id_y + 1) * width + (id_x)];

		if (id_x < width - 1)
			neighbors[7] = d_labelArray[(id_y + 1) * width + (id_x + 1)];
		else
			neighbors[7] = -1;
	} else {
		neighbors[5] = -1;
		neighbors[6] = -1;
		neighbors[7] = -1;
	}

	for (int i = 0; i < 8; i++) {
		if ((neighbors[i] != -1) && (neighbors[i] < label2)) {
			label2 = neighbors[i];
		}
	}
	if (label2 < label1) {
		atomicMin(d_equivArray + label1, label2);
		//d_equivArray[tid] = label2;
		*update = 1;
	}
	return;
}

__global__ void analysisKernel1(int* d_labelArray,
		int* d_equivArray,
		unsigned int* d_compactedIndexArray,
		int numValidPix) {

	const int tid = blockDim.x * blockIdx.x + threadIdx.x;

	if(tid < numValidPix) {

		int id = d_compactedIndexArray[tid];

		int ref = d_equivArray[id];
		while (ref != -1 && ref != d_equivArray[ref]) {
			ref = d_equivArray[ref];
		}
		d_equivArray[id] = ref;
	}

}

__global__ void labellingKernek1(int* d_labelArray,
		int* d_equivArray,
		unsigned int* d_compactedIndexArray,
		int numValidPix) {

	const int tid = blockDim.x * blockIdx.x + threadIdx.x;

	if(tid < numValidPix) {
		int id = d_compactedIndexArray[tid];
		//d_labelArray[tid] = d_equivArray[d_labelArray[tid]];
		d_labelArray[id] = d_equivArray[id];
	}
}

__global__ void cuttinglabelInit_kernel(unsigned int *d_label, unsigned int h_numValidObj) {

	const int tid = blockDim.x * blockIdx.x + threadIdx.x;
	if(tid < h_numValidObj)
		d_label[tid] = 1;
}

//needed to be improved later on.
__global__ void debDthreshInit_kernel(float *d_debDthresh,
		unsigned int 	*d_finalDebObjIndexArray,
		unsigned int 	*d_finalDebPixelIndexArray,
		int 			*d_rootLabelArray,
		float 			*d_multiThreshArray,
		int 			level,
		unsigned int 	h_numValidObj) {

	const int tid = blockDim.x * blockIdx.x + threadIdx.x;

	if(tid < h_numValidObj)
	{
		unsigned int first_index = d_finalDebPixelIndexArray[d_finalDebObjIndexArray[tid]];
		int rootlabel = d_rootLabelArray[first_index];
		d_debDthresh[tid] = d_multiThreshArray[(level-1)*h_numValidObj + rootlabel-1];
	}

}

//compute obj.fdflux - obj.dthresh*obj.fdnpix(in original order produced by analysis)
//value0 = objlist[0].obj[0].fdflux*prefs.deblend_mincont;
//need to be improved later on
__global__ void computePruneFlag_kernel(unsigned int *d_flag,
		float 			*d_fdflux,
		float			*d_dthresh,
		unsigned int 	*d_fdnpix,
		float			*d_rootfdflux,
		int				*d_rootLabelArray,
		double 			deblend_mincont,
		unsigned int	*d_finalDebPixelIndexArray,
		unsigned int	*d_finalDebObjIndexArray,
		unsigned int 	h_numValidObj) {

	const int tid = blockDim.x * blockIdx.x + threadIdx.x;

	if(tid < h_numValidObj) {

		unsigned int first_index = d_finalDebPixelIndexArray[d_finalDebObjIndexArray[tid]];
		int rootlabel = d_rootLabelArray[first_index];
		double value0 = d_rootfdflux[rootlabel-1] * deblend_mincont;

		if(d_fdflux[tid] - d_dthresh[tid]*d_fdnpix[tid] > value0)
			d_flag[tid] = 1;
		else
			d_flag[tid] = 0;
	}
	//int rootlabel =
	//float rootfdflux = d_rootflux

}
//////////////////////////////////////////////////////////////////////////
/**
 * allocated global vars:d_multiThreshArray
 * 						 d_rootLabelArray
 */
extern "C" void init_deblend(float basethresh,
		int _deblend_nthresh,
		size_t numValidObj,
		size_t numValidPix) {

	int grid_obj = (((int)numValidObj-1)/(MAX_THREADS_PER_BLK)+1);
	int block_obj = (MAX_THREADS_PER_BLK);

	int grid_pix = (((int)numValidPix-1)/(MAX_THREADS_PER_BLK)+1);
	int block_pix = (MAX_THREADS_PER_BLK);

	checkCudaErrors(cudaMalloc((void**)(&d_multiThreshArray),
			numValidObj*(_deblend_nthresh-1)*sizeof(float)));
	checkCudaErrors(cudaMalloc((void**)(&d_rootLabelArray), width*height * sizeof(int)));
	checkCudaErrors(cudaMemset(d_rootLabelArray, -1, width * height * sizeof(int)));

	computeMultiThreshKernel<<<grid_obj, block_obj>>>(d_multiThreshArray,
			d_fdpeakArray,
			basethresh,
			_deblend_nthresh,
			numValidObj);

	rootLabelInitKernel<<<grid_pix, block_pix>>>(d_rootLabelArray,
			d_finalLabelArray,
			d_finalPixelIndexArray,
			numValidPix);

	/*
	d_compactedDebLabelArray = (unsigned int**)malloc(_deblend_nthresh*sizeof(unsigned int*));
	d_compactedDebIndexArray = (unsigned int**)malloc(_deblend_nthresh*sizeof(unsigned int*));
	d_compactedDebPixelArray = (float**)malloc(_deblend_nthresh*sizeof(float*));
	d_compactedDebCdPixelArray = (float**)malloc(_deblend_nthresh*sizeof(float*));
	d_segmentDebMask = (unsigned int**)malloc(_deblend_nthresh*sizeof(unsigned int*));
	d_compactedDebParentLabel =(unsigned int**)malloc(_deblend_nthresh*sizeof(unsigned int*));*/

	d_debPixelCountArray = (unsigned int**)malloc(_deblend_nthresh*sizeof(unsigned int*));
	d_debXminArray = (unsigned int**)malloc(_deblend_nthresh*sizeof(unsigned int*));
	d_debXmaxArray = (unsigned int**)malloc(_deblend_nthresh*sizeof(unsigned int*));
	d_debYminArray = (unsigned int**)malloc(_deblend_nthresh*sizeof(unsigned int*));
	d_debYmaxArray = (unsigned int**)malloc(_deblend_nthresh*sizeof(unsigned int*));

	d_debFdpeakArray = (float**)malloc(_deblend_nthresh*sizeof(float*));
	d_debDpeakArray = (float**)malloc(_deblend_nthresh*sizeof(float*));
	d_debFdfluxArray = (float**)malloc(_deblend_nthresh*sizeof(float*));
	d_debDthresh = (float**)malloc(_deblend_nthresh*sizeof(float*));

	d_debFlagArray = (short**)malloc(_deblend_nthresh*sizeof(short*));
	d_debOk = (short**)malloc(_deblend_nthresh*sizeof(short*));
	d_debParentLabel = (unsigned int**)malloc(_deblend_nthresh*sizeof(unsigned int*));

	d_finalDebPixelIndexArray = (unsigned int**)malloc(_deblend_nthresh*sizeof(unsigned int*));
	d_finalDebObjIndexArray = (unsigned int**)malloc(_deblend_nthresh*sizeof(unsigned int*));
	d_finalDebLabelArray = (unsigned int**)malloc(_deblend_nthresh*sizeof(unsigned int*));
}

void init_level0() {

	d_debPixelCountArray[0] = d_pixelCountArray;
	d_debXminArray[0]		= d_xminArray;
	d_debXmaxArray[0]		= d_xmaxArray;
	d_debYminArray[0]		= d_yminArray;
	d_debYmaxArray[0]		= d_ymaxArray;
	d_debFdpeakArray[0]		= d_fdpeakArray;
	d_debDpeakArray[0]		= d_dpeakArray;
	d_debFdfluxArray[0]		= d_fdfluxArray;
	d_debDthresh[0]			= d_dthresh;

	d_debFlagArray[0]		= d_flagArray;
	d_debOk[0]				= d_ok;

	d_debParentLabel[0]		= NULL;

	d_finalDebLabelArray[0] = d_finalLabelArray;
	d_finalDebPixelIndexArray[0] = d_finalPixelIndexArray;
	d_finalDebObjIndexArray[0] = d_finalObjIndexArray;

}
//d_labelArray has been changed here
/**
 * allocated global vars: d_compactedDebIndexArray
 */
extern "C" void parcel_out(float basethresh,
		int n_thresh,
		int deb_minarea,
		size_t numValidObj,
		size_t numValidPix) {

	cudaEvent_t start, stop;
	float time;
	cudaEventCreate(&start);
	cudaEventCreate(&stop);
	cudaEventRecord(start, 0);
	////////////////////////////////////////

	int 		*d_update;
	int 		*h_update;
	size_t	 	h_numPixAboveThresh;

	dim3 grid((width - 1) / SQUARE_BLK_WIDTH + 1,
			 (height - 1) / SQUARE_BLK_HEIGHT + 1);
	dim3 block(SQUARE_BLK_WIDTH, SQUARE_BLK_HEIGHT);

	checkCudaErrors(cudaMalloc((void**)(&d_update), sizeof(int)));

	h_update = (int*) malloc(sizeof(int));
	h_finalValidObj = (size_t*) malloc(n_thresh*sizeof(size_t));
	h_finalValidPix = (size_t*) malloc(n_thresh*sizeof(size_t));

	h_finalValidObj[0] = numValidObj;
	h_finalValidPix[0] = numValidPix;

	init_level0();
	////////////////////////////////

	for(int i=1; i<2; i++) {

		//can also be initialized by kernel with size h_finalValidPix[0]
		checkCudaErrors(cudaMemset(d_labelArray, -1, width * height * sizeof(int)));
		checkCudaErrors(cudaMemset(d_equivArray, -1, width * height * sizeof(int)));
		checkCudaErrors(cudaMemset(d_compactMask, 0, width * height * sizeof(unsigned int)));

		int grid_pix = (((int)h_finalValidPix[i-1]-1)/(MAX_THREADS_PER_BLK)+1);
		int block_pix = (MAX_THREADS_PER_BLK);

		deblendInit_kernel<<<grid_pix, block_pix>>>(d_cdPixArray,
				d_labelArray,
				d_equivArray,
				d_compactMask,
				d_finalDebPixelIndexArray[i-1],
				d_rootLabelArray,
				d_multiThreshArray,
				h_finalValidObj[0],
				h_finalValidPix[i-1],
				i);

		/*
		//create sum reduce configuration(for computing the num. valid objs).
		CUDPPConfiguration scanconfig;
		scanconfig.op = CUDPP_ADD;
		scanconfig.datatype = CUDPP_UINT;
		scanconfig.algorithm = CUDPP_REDUCE;

		CUDPPHandle scanplan;
		CUDPPResult res;
		res = cudppPlan(theCudpp, &scanplan, scanconfig, h_finalValidPix[i-1], 1, 0);
		if (CUDPP_SUCCESS != res)
		{
			printf("Error creating CUDPP reduce Plan in %s at line %d\n", __FILE__, __LINE__);
			exit(-1);
		}

		res = cudppReduce(scanplan, d_numPixAboveThresh, d_compactMask, h_finalValidPix[i-1]);
		if (CUDPP_SUCCESS != res)
		{
			printf("Error in running the  CUDPP reduce in %s at line %d\n", __FILE__, __LINE__);
			exit(-1);
		}

		// Destroy the reduce plan
		res = cudppDestroyPlan(scanplan);
		if (CUDPP_SUCCESS != res)
		{
			printf("Error destroying CUDPP reduce Plan in %s at line %d\n", __FILE__, __LINE__);
			exit(-1);
		}*/

		CUDPPResult res;

		////////////////////////////////////
		//compact the index array(also label array before detection)

		//create and allocate the compacted index array space for output(freed in the clear function)
		//checkCudaErrors(cudaMalloc( (void**) &d_compactedDebIndexArray[i], h_numPixAboveThresh * sizeof(unsigned int)));
		//checkCudaErrors(cudaMalloc( (void**) &d_compactedDebParentLabel[i], h_numPixAboveThresh * sizeof(unsigned int)));

		//create the configuration for compact
		CUDPPConfiguration compactconfig;
		compactconfig.datatype = CUDPP_INT;
		compactconfig.algorithm = CUDPP_COMPACT;

		//create the cudpp compact plan
		CUDPPHandle compact;
		res = cudppPlan(theCudpp, &compact, compactconfig, (int)h_finalValidPix[i-1], 1, 0);
		if (CUDPP_SUCCESS != res)
		{
			printf("Error creating CUDPP compact Plan in %s at line %d\n", __FILE__, __LINE__);
			exit(-1);
		}

		// Run the compact for index array
		res = cudppCompact(compact, d_compactedIndexArray, d_numPixAboveThresh,
				d_finalDebPixelIndexArray[i-1],
				d_compactMask,
				(int)h_finalValidPix[i-1]);
		if (CUDPP_SUCCESS != res)
		{
			printf("Error running CUDPP compact in %s at line %d\n", __FILE__, __LINE__);
			exit(-1);
		}

		//Run the compact for parent label array
		res = cudppCompact(compact, d_compactedParentLabel, d_numPixAboveThresh,
				d_finalDebLabelArray[i-1],
				d_compactMask,
				(int)h_finalValidPix[i-1]);
		if (CUDPP_SUCCESS != res)
		{
			printf("Error running CUDPP compact in %s at line %d\n", __FILE__, __LINE__);
			exit(-1);
		}

		/*
		unsigned int *label = (unsigned int*)malloc(400*sizeof(unsigned int));
		cudaMemcpy(label, d_compactMask, sizeof(unsigned int)*400, cudaMemcpyDeviceToHost);
		for(int tt=0; tt<400; tt++)
			printf("label is %d\n", label[tt]);*/

		// Destroy the int compact plan
		res = cudppDestroyPlan(compact);
		checkcudppSuccess(res, "Error destroying CUDPP compact Plan");

		cudaMemcpy(&h_numPixAboveThresh, d_numPixAboveThresh, sizeof(size_t), cudaMemcpyDeviceToHost);
		/////////////////////////////////////////////
		//end of compact

		int count = 0;
		int detection_grid = ((int)h_numPixAboveThresh-1)/(MAX_THREADS_PER_BLK)+1;
		int detection_block = (MAX_THREADS_PER_BLK);

		while(1) {
			*h_update = 0;
			cudaMemcpy(d_update, h_update, sizeof(int), cudaMemcpyHostToDevice);
			scanKernel1<<<detection_grid, detection_block>>>(d_labelArray,
					d_equivArray,
					d_compactedIndexArray,
					h_numPixAboveThresh,
					width,
					height,
					d_update);

			analysisKernel1<<<detection_grid, detection_block>>>(d_labelArray,
					d_equivArray,
					d_compactedIndexArray,
					h_numPixAboveThresh);

			labellingKernek1<<<detection_grid, detection_block>>>(d_labelArray,
					d_equivArray,
					d_compactedIndexArray,
					h_numPixAboveThresh);

//			cudaMemcpy(d_labelArray, d_equivArray, width*height*sizeof(int), cudaMemcpyDeviceToDevice);
			cudaMemcpy(h_update, d_update, sizeof(int), cudaMemcpyDeviceToHost);
			count++;

			if(!(*h_update))
				break;
		}
		compact_and_sort1(h_numPixAboveThresh, i);
		h_finalValidPix[i] = pre_analyse1(h_numPixAboveThresh, deb_minarea, &h_finalValidObj[i], i);

		//cut_branch(i, 0.0005);

		//printf("h_numPixAboveThresh is %d\n", h_numPixAboveThresh);
<<<<<<< .mine
		printf("level %d, h_finalValidPix is %d, h_finalValidObj is %d\n", i, (int)h_numPixAboveThresh, (int)h_finalValidObj[i]);

		//checkCudaErrors(cudaFree(d_compactMask));
=======
		printf("level %d, h_finalValidPix is %d, h_finalValidObj is %d\n", i, (int)h_finalValidPix[i], (int)h_finalValidObj[i]);
>>>>>>> .r18
	}

	/////////////////////////////////////////////////////////////
	checkCudaErrors(cudaFree(d_update));

	free(h_update);
	free(h_finalValidObj);
	free(h_finalValidPix);

	cudaEventRecord(stop, 0);
	cudaEventSynchronize(stop);
	cudaEventElapsedTime(&time, start, stop);
	printf("Time counsumed by deblend is: %f\n", time/1000);
	cudaEventDestroy(start);
	cudaEventDestroy(stop);

	//////////////
}

/**
 * allocated global vars: d_compactedDebLabelArray[level],
 * 						  d_compactedDebPixelArray[level],
 * 						  d_compactedDebCdPixelArray[level]
 * 						  d_segmentDebMask[level]
 */
void compact_and_sort1(size_t numPixAboveThresh, int level) {

	CUDPPResult res;

	int grid = ((int)numPixAboveThresh-1)/(MAX_THREADS_PER_BLK)+1;
	int block = (MAX_THREADS_PER_BLK);

	//checkCudaErrors(cudaMalloc( (void**) &d_compactedDebLabelArray[level], numPixAboveThresh * sizeof(unsigned int)));

	getLabelFromIndexKernel<<<grid, block>>>(d_compactedIndexArray,
			d_labelArray,
			d_compactedLabelArray,
			numPixAboveThresh);

	////////////////////////////////////////////
	// Create the configuration for sort
	CUDPPConfiguration sort_config;
	sort_config.datatype = CUDPP_INT;
	sort_config.algorithm = CUDPP_SORT_RADIX;
	sort_config.options = CUDPP_OPTION_KEY_VALUE_PAIRS;

	//create the cudpp sort plan
	CUDPPHandle sortplan = 0;
	res = cudppPlan(theCudpp, &sortplan, sort_config, (int)numPixAboveThresh, 1, 0);
	if (CUDPP_SUCCESS != res)
	{
		printf("Error creating CUDPP sort Plan in %s at line %d\n", __FILE__, __LINE__);
		exit(-1);
	}
	// Run the sort
	res = cudppSort(sortplan, d_compactedLabelArray,
			d_compactedIndexArray, (int)numPixAboveThresh);
	if (CUDPP_SUCCESS != res)
	{
		printf("Error in cudppSort() for sorting compacted labels in %s at line %d\n", __FILE__, __LINE__);
		exit(-1);
	}

	// Destroy the sort plan
	res = cudppDestroyPlan(sortplan);
	if (CUDPP_SUCCESS != res)
	{
		printf("Error destroying CUDPP sort Plan in %s at line %d\n", __FILE__, __LINE__);
		exit(-1);
	}

	//initialize the segment mask array according to the compacted label array.
	//(1 for the start pos of a segment, 0 otherwise)
	segmentMaskInitKernel<<<grid, block>>>(d_compactedLabelArray,
			d_segmentMask, numPixAboveThresh);

	//initialize the compacted pixel array according to the original pixel array
	//and the compacted index array.
	getPixelFromIndexKernel<<<grid, block>>>(d_compactedIndexArray,
			d_pixelArray, d_compactedPixelArray, numPixAboveThresh);

	//initialize the compacted cd pixel array according to the original pixel array
	//and the compacted index array.
	getPixelFromIndexKernel<<<grid, block>>>(d_compactedIndexArray,
			d_cdPixArray, d_compactedcdPixelArray, numPixAboveThresh);

	//////////////////////////////////////////////////////////////////////
}

/**
 *  allocated but not freed global array in this method:
 *	d_debPixelCountArray (d_deb***Array totally 10)
 *	d_finalDebPixelIndexArray
 *	d_finalDebObjIndexArray
 *	d_finalDebLabelArray
 *	d_debParentLabel
 *
 *	deleted global vars:
 *
 *	d_compactedDebIndexArray
	d_compactedDebLabelArray
	d_compactedDebPixelArray
	d_compactedDebCdPixelArray
	d_segmentDebMask
	d_compactedDebParentLabel
 */
size_t pre_analyse1(size_t compactedArraysize,
		size_t deb_maxarea,
		size_t* numValidObj,
		int level) {

	//reserved space to place the final result for pre-analysis
	//one elements for each objects
	static unsigned int	*d_numValidObj;
	unsigned int	h_numValidObj;

	static unsigned int	*d_numValidPix;
	unsigned int  	h_numValidPix;

	static size_t		*d_numCompactedObj;
	static size_t		*d_numCompactedPix;

	//static unsigned int *d_prunedSegmentMask;
	//static unsigned int	*d_compactMask2;

	///////////////////////////////////////////////
	if(level == 1)
	{	/*
		checkCudaErrors(cudaMalloc((void**) &d_pixelCountMask, compactedArraysize * sizeof(unsigned int)));
		checkCudaErrors(cudaMalloc((void**) &d_pixelCountSegment, compactedArraysize * sizeof(unsigned int)));
		checkCudaErrors(cudaMalloc((void**) &d_xposSegment, compactedArraysize * sizeof(unsigned int)));
		checkCudaErrors(cudaMalloc((void**) &d_yposSegment, compactedArraysize * sizeof(unsigned int)));
		checkCudaErrors(cudaMalloc((void**) &d_xminSegment, compactedArraysize * sizeof(unsigned int)));
		checkCudaErrors(cudaMalloc((void**) &d_xmaxSegment, compactedArraysize * sizeof(unsigned int)));
		checkCudaErrors(cudaMalloc((void**) &d_yminSegment, compactedArraysize * sizeof(unsigned int)));
		checkCudaErrors(cudaMalloc((void**) &d_ymaxSegment,	compactedArraysize * sizeof(unsigned int)));
		checkCudaErrors(cudaMalloc((void**) &d_fdpeakSegment, compactedArraysize * sizeof(float)));
		checkCudaErrors(cudaMalloc((void**) &d_dpeakSegment, compactedArraysize * sizeof(float)));
		checkCudaErrors(cudaMalloc((void**) &d_fdfluxSegment, compactedArraysize * sizeof(float)));*/
	}

	////////////////////////////////////////////////////

	//initialize all the elements in d_pixelCountMask
	int grid1 = ((int)compactedArraysize-1)/(MAX_THREADS_PER_BLK)+1;
	int block1 = (MAX_THREADS_PER_BLK);
	pixelCountMaskInitKernel<<<grid1, block1>>>(d_pixelCountMask, compactedArraysize);

	xyposFromIndexKernel<<<grid1, block1>>>(d_compactedIndexArray,
			d_xposSegment,
			d_yposSegment,
			compactedArraysize,
			width);

	//////////////////////////////////////////////
	//create prefix scan configuration
	CUDPPConfiguration scanconfig;
	scanconfig.op = CUDPP_ADD;
	scanconfig.datatype = CUDPP_UINT;
	scanconfig.algorithm = CUDPP_SEGMENTED_SCAN;
	scanconfig.options = CUDPP_OPTION_BACKWARD | CUDPP_OPTION_INCLUSIVE;

	//create segment prefix scan plan
	CUDPPHandle scanplan = 0;
	CUDPPResult res = cudppPlan(theCudpp, &scanplan, scanconfig, compactedArraysize, 1, 0);
	checkcudppSuccess(res, "Error creating CUDPP segment mask array scan Plan");

	res = cudppSegmentedScan(scanplan,
			d_pixelCountSegment,
			d_pixelCountMask,
			d_segmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the segment pixel count scan");

	// Destroy the segment prefix scan plan
	res = cudppDestroyPlan(scanplan);
	checkcudppSuccess(res, "Error destroying CUDPP segment pixel count scan Plan");

	//////////////////////////////////////////////
	//create max scan configuration

	scanconfig.op = CUDPP_MAX;
	scanconfig.datatype = CUDPP_UINT;
	scanconfig.algorithm = CUDPP_SEGMENTED_SCAN;
	scanconfig.options = CUDPP_OPTION_BACKWARD | CUDPP_OPTION_INCLUSIVE;

	res = cudppPlan(theCudpp, &scanplan, scanconfig, compactedArraysize, 1, 0);
	checkcudppSuccess(res, "Error creating CUDPP segment max scan Plan");

	res = cudppSegmentedScan(scanplan,
			d_xmaxSegment,
			d_xposSegment,
			d_segmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the segment x max scan");

	res = cudppSegmentedScan(scanplan,
			d_ymaxSegment,
			d_yposSegment,
			d_segmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the segment y max scan");

	// Destroy the segment prefix scan plan
	res = cudppDestroyPlan(scanplan);
	checkcudppSuccess(res, "Error destroying CUDPP segment max scan Plan");

	//////////////////////////////////////////////
	//create min scan configuration
	scanconfig.op = CUDPP_MIN;
	scanconfig.datatype = CUDPP_UINT;
	scanconfig.algorithm = CUDPP_SEGMENTED_SCAN;
	scanconfig.options = CUDPP_OPTION_BACKWARD | CUDPP_OPTION_INCLUSIVE;

	res = cudppPlan(theCudpp, &scanplan, scanconfig, compactedArraysize, 1, 0);
	checkcudppSuccess(res, "Error creating CUDPP segment min scan Plan");

	res = cudppSegmentedScan(scanplan,
			d_xminSegment,
			d_xposSegment,
			d_segmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the segment x min scan");

	res = cudppSegmentedScan(scanplan,
			d_yminSegment,
			d_yposSegment,
			d_segmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the segment y min scan");

	// Destroy the segment prefix scan plan
	res = cudppDestroyPlan(scanplan);
	checkcudppSuccess(res, "Error destroying CUDPP segment min scan Plan");

	////////////////////////////////////////////////////
	//create float max scan configuration(for fdpeak and dpeak).
	scanconfig.op = CUDPP_MAX;
	scanconfig.datatype = CUDPP_FLOAT;
	scanconfig.algorithm = CUDPP_SEGMENTED_SCAN;

	res = cudppPlan(theCudpp, &scanplan, scanconfig, compactedArraysize, 1, 0);
	checkcudppSuccess(res, "Error creating CUDPP segment float max scan Plan");

	res = cudppSegmentedScan(scanplan,
			d_fdpeakSegment,
			d_compactedcdPixelArray,
			d_segmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the segment fdpeak scan");

	res = cudppSegmentedScan(scanplan,
			d_dpeakSegment,
			d_compactedPixelArray,
			d_segmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the segment dpeak scan");

	// Destroy the segment prefix scan plan
	res = cudppDestroyPlan(scanplan);
	checkcudppSuccess(res, "Error destroying CUDPP segment float max scan Plan");

	////////////////////////////////////////////////////
	//create float sum scan configuration(for fdflux).
	scanconfig.op = CUDPP_ADD;
	scanconfig.datatype = CUDPP_FLOAT;
	scanconfig.algorithm = CUDPP_SEGMENTED_SCAN;

	res = cudppPlan(theCudpp, &scanplan, scanconfig, compactedArraysize, 1, 0);
	checkcudppSuccess(res, "Error creating CUDPP segment float sum scan Plan");


	res = cudppSegmentedScan(scanplan,
			d_fdfluxSegment,
			d_compactedcdPixelArray, //?????
			d_segmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the segment fdflux scan");

	// Destroy the segment prefix scan plan
	res = cudppDestroyPlan(scanplan);
	checkcudppSuccess(res, "Error destroying CUDPP segment float sum scan Plan");

	////////////////////////////////////////////////////
	if(level == 1)
	{
		//checkCudaErrors(cudaMalloc((void**) &d_prunedSegmentMask, compactedArraysize*sizeof(unsigned int)));
		checkCudaErrors(cudaMalloc((void**) &d_numValidObj, sizeof(unsigned int)));
	}

	segmentmask_prune_kernel<<<grid1, block1>>>(
			d_segmentMask,
			d_prunedSegmentMask,
			d_pixelCountSegment,
			compactedArraysize,
			deb_maxarea);
	////////////////////////////////////////////////////

	//create sum reduce configuration(for computing the num. valid objs).
	scanconfig.op = CUDPP_ADD;
	scanconfig.datatype = CUDPP_UINT;
	scanconfig.algorithm = CUDPP_REDUCE;

	res = cudppPlan(theCudpp, &scanplan, scanconfig, compactedArraysize, 1, 0);
	checkcudppSuccess(res, "Error creating CUDPP reduce Plan(to get the num. of valid obj)");

	res = cudppReduce(scanplan,
			d_numValidObj,
			d_prunedSegmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the  CUDPP reduce(to get the num. of valid obj)");

	// Destroy the reduce plan
	res = cudppDestroyPlan(scanplan);
	checkcudppSuccess(res, "Error destroying CUDPP reduce Plan(to get the num. of valid obj)");

	cudaMemcpy(&h_numValidObj, d_numValidObj, sizeof(unsigned int), cudaMemcpyDeviceToHost);
	//std::cout << "number of valid object in the deb scan is " << (*_h_finalValidObj) << std::endl;
	*numValidObj = h_numValidObj;
	///////////////////////////////////////////////////

	//allocate memory space to store the valid object properties.
	checkCudaErrors(cudaMalloc((void**) &d_debPixelCountArray[level], h_numValidObj*sizeof(unsigned int)));
	checkCudaErrors(cudaMalloc((void**) &d_debXminArray[level], h_numValidObj*sizeof(unsigned int)));
	checkCudaErrors(cudaMalloc((void**) &d_debXmaxArray[level], h_numValidObj*sizeof(unsigned int)));
	checkCudaErrors(cudaMalloc((void**) &d_debYminArray[level], h_numValidObj*sizeof(unsigned int)));
	checkCudaErrors(cudaMalloc((void**) &d_debYmaxArray[level], h_numValidObj*sizeof(unsigned int)));
	checkCudaErrors(cudaMalloc((void**) &d_debFdpeakArray[level], h_numValidObj*sizeof(float)));
	checkCudaErrors(cudaMalloc((void**) &d_debDpeakArray[level], h_numValidObj*sizeof(float)));
	checkCudaErrors(cudaMalloc((void**) &d_debFdfluxArray[level], h_numValidObj*sizeof(float)));
	checkCudaErrors(cudaMalloc((void**) &d_debDthresh[level], h_numValidObj*sizeof(float)));

	checkCudaErrors(cudaMalloc((void**) &d_debFlagArray[level], h_numValidObj*sizeof(short)));
	checkCudaErrors(cudaMalloc((void**) &d_debOk[level], h_numValidObj*sizeof(short)));

	checkCudaErrors(cudaMalloc((void**) &d_debParentLabel[level], h_numValidObj*sizeof(unsigned int)));

	////////////////////////////////////////////////////
	if(level == 1)
	{
		checkCudaErrors(cudaMalloc((void**) &d_numCompactedObj, sizeof(size_t)));
	}

	//create compact scan configuration(for computing the properties of valid objs).
	CUDPPConfiguration compactconfig;
	compactconfig.datatype = CUDPP_INT;
	compactconfig.algorithm = CUDPP_COMPACT;

	//create the cudpp compact plan
	CUDPPHandle compact = 0;
	res = cudppPlan(theCudpp, &compact, compactconfig, compactedArraysize, 1, 0);
	checkcudppSuccess(res, "Error creating CUDPP compact Plan(to compute the properties of valid objs)");

	res = cudppCompact(compact,
			d_debPixelCountArray[level],
			d_numCompactedObj,
			d_pixelCountSegment,
			d_prunedSegmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the  CUDPP compact (to compute the d_pixelCountArray properties of valid objs)");

	res = cudppCompact(compact,
			d_debXminArray[level],
			d_numCompactedObj,
			d_xminSegment,
			d_prunedSegmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the  CUDPP compact (to compute the d_xminArray properties of valid objs)");

	res = cudppCompact(compact,
			d_debXmaxArray[level],
			d_numCompactedObj,
			d_xmaxSegment,
			d_prunedSegmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the  CUDPP compact (to compute the d_xmaxArray properties of valid objs)");

	res = cudppCompact(compact,
			d_debYminArray[level],
			d_numCompactedObj,
			d_yminSegment,
			d_prunedSegmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the  CUDPP compact (to compute the d_yminArray properties of valid objs)");

	res = cudppCompact(compact,
			d_debYmaxArray[level],
			d_numCompactedObj,
			d_ymaxSegment,
			d_prunedSegmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the  CUDPP compact (to compute the d_ymaxArray properties of valid objs)");

	res = cudppCompact(compact,
			d_debParentLabel[level],
			d_numCompactedObj,
			d_compactedParentLabel,
			d_prunedSegmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the  CUDPP compact (to compute the d_ymaxArray properties of valid objs)");

	// Destroy the compact plan
	res = cudppDestroyPlan(compact);
	checkcudppSuccess(res, "Error destroying CUDPP compact Plan(to compute the int properties of valid objs)");

	///////////////////////////////////////////////
	//create compact scan configuration(for computing the properties of valid objs).
	compactconfig.datatype = CUDPP_FLOAT;
	compactconfig.algorithm = CUDPP_COMPACT;

	res = cudppPlan(theCudpp, &compact, compactconfig, compactedArraysize, 1, 0);
	checkcudppSuccess(res, "Error creating CUDPP compact Plan(to compute the float properties of valid objs)");

	res = cudppCompact(compact,
			d_debFdpeakArray[level],
			d_numCompactedObj,
			d_fdpeakSegment,
			d_prunedSegmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the  CUDPP compact (to compute the d_fdpeakArray properties of valid objs)");

	res = cudppCompact(compact,
			d_debDpeakArray[level],
			d_numCompactedObj,
			d_dpeakSegment,
			d_prunedSegmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the  CUDPP compact (to compute the d_dpeakArray properties of valid objs)");

	res = cudppCompact(compact,
			d_debFdfluxArray[level],
			d_numCompactedObj,
			d_fdfluxSegment,
			d_prunedSegmentMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error in running the  CUDPP compact (to compute the d_fdfluxArray properties of valid objs)");

	// Destroy the compact plan
	res = cudppDestroyPlan(compact);
	checkcudppSuccess(res, "Error destroying CUDPP compact Plan(to compute the float properties of valid objs)");

	////////////////////////////////////////////////////////////////

	cudaMemset(d_debFlagArray[level], 0, h_numValidObj * sizeof(short));

	grid1 = (h_numValidObj-1)/(MAX_THREADS_PER_BLK)+1;
	block1 = (MAX_THREADS_PER_BLK);
	checkTruncKernel<<<grid1, block1>>>(d_debXminArray[level],
			d_debXmaxArray[level],
			d_debYminArray[level],
			d_debYmaxArray[level],
			d_debFlagArray[level],
			h_numValidObj,
			width,
			height);

	okInit_kernel<<<grid1, block1>>>(d_debOk[level], h_numValidObj);

////////////////////////////////////////////////////////////////
	if(level == 1)
	{
		//checkCudaErrors(cudaMalloc((void**) &d_compactMask2, compactedArraysize*sizeof(unsigned int)));
	}

	//create backward segment scan configuration(to compact the label and index array)
	CUDPPConfiguration segconfig;
	segconfig.op = CUDPP_ADD;
	segconfig.datatype = CUDPP_UINT;
	segconfig.algorithm = CUDPP_SEGMENTED_SCAN;
	segconfig.options = CUDPP_OPTION_FORWARD | CUDPP_OPTION_INCLUSIVE;

	//create prefix scan plan
	CUDPPHandle segscanplan = 0;
	res = cudppPlan(theCudpp, &segscanplan, segconfig, compactedArraysize, 1, 0);
	checkcudppSuccess(res, "Error creating CUDPP backward segment scan Plan(for segment end mask scan)");

	//perform a forward segment sum scan of the segment end mask array (for label and index array compact)
	res = cudppSegmentedScan(segscanplan, d_compactMask, d_prunedSegmentMask,
			d_segmentMask, compactedArraysize);
	checkcudppSuccess(res, "Error in running the segment sum scan(for segment end mask array)");

	// Destroy the segment scan plan
	res = cudppDestroyPlan(segscanplan);
	checkcudppSuccess(res, "Error destroying CUDPP prefix scan Plan(for segment end mask array)");

//////////////////////////////////
	if(level == 1)
		checkCudaErrors(cudaMalloc((void**) &d_numValidPix, sizeof(unsigned int)));

	//create sum reduce configuration(for computing the num. valid pixels).
	scanconfig.op = CUDPP_ADD;
	scanconfig.datatype = CUDPP_UINT;
	scanconfig.algorithm = CUDPP_REDUCE;

	res = cudppPlan(theCudpp, &scanplan, scanconfig, compactedArraysize, 1, 0);
	checkcudppSuccess(res, "Error creating CUDPP reduce Plan(to get the num. of valid pixels)");

	res = cudppReduce(scanplan, d_numValidPix, d_compactMask, compactedArraysize);
	checkcudppSuccess(res, "Error in running the  CUDPP reduce(to get the num. of valid pixels)");

	// Destroy the reduce plan
	res = cudppDestroyPlan(scanplan);
	checkcudppSuccess(res, "Error destroying CUDPP reduce Plan(to get the num. of valid pixels)");

	checkCudaErrors(cudaMemcpy(&h_numValidPix, d_numValidPix, sizeof(unsigned int),
			cudaMemcpyDeviceToHost));
	//std::cout << "number of valid pixel after deb is " << (*_h_finalValidPix) << std::endl;

////////////////////////////////////////////////////////////
	//allocate space for final compacted label and index array
	checkCudaErrors(cudaMalloc((void**) &d_finalDebObjIndexArray[level], h_numValidObj*sizeof(unsigned int)));
	checkCudaErrors(cudaMalloc((void**) &d_finalDebPixelIndexArray[level], h_numValidPix*sizeof(unsigned int)));
	checkCudaErrors(cudaMalloc((void**) &d_finalDebLabelArray[level], h_numValidPix*sizeof(unsigned int)));
	checkCudaErrors(cudaMalloc((void**) &d_numCompactedPix, sizeof(size_t)));

	//create compact scan configuration(for the final compact of label and index array).
	compactconfig.datatype = CUDPP_UINT;
	compactconfig.algorithm = CUDPP_COMPACT;

	res = cudppPlan(theCudpp, &compact, compactconfig, compactedArraysize, 1, 0);
	checkcudppSuccess(res, "Error creating CUDPP compact Plan(for the final compact of label and index array)");

	res = cudppCompact(compact,
			d_finalDebLabelArray[level],
			d_numCompactedPix,
			d_compactedLabelArray,
			d_compactMask,
			compactedArraysize);
	checkcudppSuccess(res, "Error running final label compact");
	res = cudppCompact(compact,
			d_finalDebPixelIndexArray[level],
			d_numCompactedPix,
			d_compactedIndexArray,
			d_compactMask,
			compactedArraysize);

	// Destroy the compact plan
	res = cudppDestroyPlan(compact);
	checkcudppSuccess(res, "Error running final index compact");

	////////////////////////////////////////////////////////////
	//initialize the segment mask array according to the final compacted label array.
	//(1 for the start pos of a segment, 0 otherwise)
	int grid2 = ((h_numValidPix)-1)/(MAX_THREADS_PER_BLK)+1;
	int block2 = (MAX_THREADS_PER_BLK);
	segmentMaskInitKernel<<<grid2, block2>>>(d_finalDebLabelArray[level],
			d_segmentMask, (h_numValidPix));

	//create prefix sum scan configuration(to make the final labels consecutive).
	scanconfig.op = CUDPP_ADD;
	scanconfig.datatype = CUDPP_INT;
	scanconfig.algorithm = CUDPP_SCAN;
	scanconfig.options = CUDPP_OPTION_FORWARD | CUDPP_OPTION_INCLUSIVE;

	//create prefix scan plan
	scanplan = 0;
	res = cudppPlan(theCudpp, &scanplan, scanconfig, (h_numValidPix), 1, 0);
	if (CUDPP_SUCCESS != res)
	{
		printf("Error creating CUDPP segment mask array scan Plan\n");
		exit(-1);
	}

	//perform a prefix sum scan of the segment mask array and output the result to the compacted label array
	//as consecutive labels
	res = cudppScan(scanplan, d_finalDebLabelArray[level], d_segmentMask, (h_numValidPix));
	if (CUDPP_SUCCESS != res)
	{
		printf("Error in running the segment mask scan\n");
		exit(-1);
	}

	// Destroy the prefix scan plan
	res = cudppDestroyPlan(scanplan);
	if (CUDPP_SUCCESS != res)
	{
		printf("Error destroying CUDPP prefix scan Plan\n");
		exit(-1);
	}
	/////////////////////////////////////////////////////////////

	//create prefix sum scan configuration(to record the pos of each obj in final index array).
	scanconfig.op = CUDPP_ADD;
	scanconfig.datatype = CUDPP_UINT;
	scanconfig.algorithm = CUDPP_SCAN;
	scanconfig.options = CUDPP_OPTION_FORWARD | CUDPP_OPTION_EXCLUSIVE;

	//create prefix scan plan
	scanplan = 0;
	res = cudppPlan(theCudpp, &scanplan, scanconfig, h_numValidObj, 1, 0);
	if (CUDPP_SUCCESS != res)
	{
		printf("Error creating CUDPP segment mask array scan Plan\n");
		exit(-1);
	}

	//perform a prefix sum scan of the pixel count array and output the result to d_finalObjIndexArray
	res = cudppScan(scanplan, d_finalDebObjIndexArray[level], d_debPixelCountArray[level], h_numValidObj);
	if (CUDPP_SUCCESS != res)
	{
		printf("Error in running the segment mask scan\n");
		exit(-1);
	}

	// Destroy the prefix scan plan
	res = cudppDestroyPlan(scanplan);
	if (CUDPP_SUCCESS != res)
	{
		printf("Error destroying CUDPP prefix scan Plan\n");
		exit(-1);
	}
	/////////////////////////////////////////////////////////////

	//must be computed after get the right d_finalDebObjIndexArray
	debDthreshInit_kernel<<<grid1, block1>>>(d_debDthresh[level],
			d_finalDebObjIndexArray[level],
			d_finalDebPixelIndexArray[level],
			d_rootLabelArray,
			d_multiThreshArray,
			level,
			h_numValidObj);

	////////////////////////////////////////////////////////////

	if(level == 31)
	{
		//checkCudaErrors(cudaFree(d_compactMask2));
		checkCudaErrors(cudaFree(d_numValidObj));
		checkCudaErrors(cudaFree(d_numCompactedObj));
		checkCudaErrors(cudaFree(d_numValidPix));
		checkCudaErrors(cudaFree(d_numCompactedPix));
		/*
		checkCudaErrors(cudaFree(d_prunedSegmentMask));

		checkCudaErrors(cudaFree(d_pixelCountMask));
		checkCudaErrors(cudaFree(d_pixelCountSegment));

		checkCudaErrors(cudaFree(d_xposSegment));
		checkCudaErrors(cudaFree(d_yposSegment));
		checkCudaErrors(cudaFree(d_xminSegment));
		checkCudaErrors(cudaFree(d_xmaxSegment));
		checkCudaErrors(cudaFree(d_yminSegment));
		checkCudaErrors(cudaFree(d_ymaxSegment));

		checkCudaErrors(cudaFree(d_fdpeakSegment));
		checkCudaErrors(cudaFree(d_dpeakSegment));
		checkCudaErrors(cudaFree(d_fdfluxSegment));*/
	}

	//global vars
	//checkCudaErrors(cudaFree(d_compactedDebIndexArray[level]));
	//checkCudaErrors(cudaFree(d_compactedDebLabelArray[level]));
	//checkCudaErrors(cudaFree(d_compactedDebPixelArray[level]));
	//checkCudaErrors(cudaFree(d_compactedDebCdPixelArray[level]));
	//checkCudaErrors(cudaFree(d_segmentDebMask[level]));
	//checkCudaErrors(cudaFree(d_compactedDebParentLabel[level]));

	return (size_t)h_numValidPix;
}

void cut_branch(int level, double DEBLEND_MINCONT) {

	int grid_obj = (h_finalValidObj[level]-1)/(MAX_THREADS_PER_BLK)+1;
	int block_obj = (MAX_THREADS_PER_BLK);

	unsigned int 	*d_label;
	unsigned int	*d_parentSegmentMask;
	unsigned int	*d_pruneFlag;

	checkCudaErrors(cudaMalloc((void**) &d_label, h_finalValidObj[level]*sizeof(unsigned int)));
	checkCudaErrors(cudaMalloc((void**) &d_parentSegmentMask, h_finalValidObj[level]*sizeof(unsigned int)));
	checkCudaErrors(cudaMalloc((void**) &d_pruneFlag, h_finalValidObj[level]*sizeof(unsigned int)));

	cuttinglabelInit_kernel<<<grid_obj, block_obj>>>(d_label, h_finalValidObj[level]);

	/////////////////////////////////////////////////////////////////////////////////
	//create the label array start with 1 2 3......
	CUDPPConfiguration scanconfig;
	scanconfig.op = CUDPP_ADD;
	scanconfig.datatype = CUDPP_UINT;
	scanconfig.algorithm = CUDPP_SCAN;
	scanconfig.options = CUDPP_OPTION_FORWARD | CUDPP_OPTION_INCLUSIVE;

	//create prefix scan plan
	CUDPPHandle scanplan = 0;
	CUDPPResult res = cudppPlan(theCudpp, &scanplan, scanconfig, h_finalValidObj[level], 1, 0);
	if (CUDPP_SUCCESS != res)
	{
		printf("Error creating CUDPP segment mask array scan Plan\n");
		exit(-1);
	}

	//perform a prefix sum scan of the d_label to get the actual label for each object
	res = cudppScan(scanplan, d_label, d_label, h_finalValidObj[level]);
	if (CUDPP_SUCCESS != res)
	{
		printf("Error in running the segment mask scan\n");
		exit(-1);
	}

	// Destroy the prefix scan plan
	res = cudppDestroyPlan(scanplan);
	if (CUDPP_SUCCESS != res)
	{
		printf("Error destroying CUDPP prefix scan Plan\n");
		exit(-1);
	}

	//////////////////////////////////////////////////////////////////////////
	//sor the label array by parent label array.
	CUDPPConfiguration sort_config;
	sort_config.datatype = CUDPP_UINT;
	sort_config.algorithm = CUDPP_SORT_RADIX;
	sort_config.options = CUDPP_OPTION_KEY_VALUE_PAIRS;

	//create the cudpp sort plan
	CUDPPHandle sortplan = 0;
	res = cudppPlan(theCudpp, &sortplan, sort_config, h_finalValidObj[level], 1, 0);
	if (CUDPP_SUCCESS != res)
	{
		printf("Error creating CUDPP sort Plan in %s at line %d\n", __FILE__, __LINE__);
		exit(-1);
	}
	// Run the sort
	res = cudppSort(sortplan, d_debParentLabel[level], d_label, h_finalValidObj[level]);
	if (CUDPP_SUCCESS != res)
	{
		printf("Error in cudppSort() for sorting compacted labels in %s at line %d\n", __FILE__, __LINE__);
		exit(-1);
	}

	// Destroy the sort plan
	res = cudppDestroyPlan(sortplan);
	if (CUDPP_SUCCESS != res)
	{
		printf("Error destroying CUDPP sort Plan in %s at line %d\n", __FILE__, __LINE__);
		exit(-1);
	}

	segmentMaskInitKernel<<<grid_obj, block_obj>>>(d_debParentLabel[level], d_parentSegmentMask, h_finalValidObj[level]);

	//compute obj.fdflux - obj.dthresh*obj.fdnpix(in original order produced by analysis)
	computePruneFlag_kernel<<<grid_obj, block_obj>>>(d_pruneFlag,
			d_debFdfluxArray[level],
			d_debDthresh[level],
			d_debPixelCountArray[level],
			d_debFdfluxArray[0],
			d_rootLabelArray,
			DEBLEND_MINCONT,
			d_finalDebPixelIndexArray[level],
			d_finalDebObjIndexArray[level],
			h_finalValidObj[level]);


	/*
	if(level <= 31)
	{
		int count = 0;
		unsigned int *h_label = (unsigned int*)malloc(h_numValidObj*sizeof(unsigned int));
		cudaMemcpy(h_label, d_finalDebObjIndexArray[level], h_numValidObj*sizeof(unsigned int), cudaMemcpyDeviceToHost);
		for(int i=0; i < h_numValidObj; i++)
			if(h_label[i] >= h_numValidPix)
				printf("count is %d\n", h_label[i]);
		free(h_label);
	}*/

	checkCudaErrors(cudaFree(d_label));
	checkCudaErrors(cudaFree(d_parentSegmentMask));
	checkCudaErrors(cudaFree(d_pruneFlag));
}

extern "C" void clear_deblend(int _deblend_nthresh) {


	//destroy the result for deb compact and sort.
	/*
	free(d_compactedDebLabelArray);
	free(d_compactedDebIndexArray);
	free(d_compactedDebPixelArray);
	free(d_compactedDebCdPixelArray);
	free(d_segmentDebMask);*/

	free(d_debPixelCountArray);
	free(d_debXminArray);
	free(d_debXmaxArray);
	free(d_debYminArray);
	free(d_debYmaxArray);
	free(d_debFdpeakArray);
	free(d_debDpeakArray);
	free(d_debFdfluxArray);
	free(d_debDthresh);

	free(d_debFlagArray);
	free(d_debOk);
	free(d_debParentLabel);

	free(d_finalDebObjIndexArray);
	free(d_finalDebPixelIndexArray);
	free(d_finalDebLabelArray);



	checkCudaErrors(cudaFree(d_multiThreshArray));
	checkCudaErrors(cudaFree(d_rootLabelArray));

	//another 11 global vars to be freed
}



