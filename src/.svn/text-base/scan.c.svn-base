/*
 				scan.c

 *%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 *
 *	Part of:	SExtractor
 *
 *	Author:		E.BERTIN (IAP)
 *
 *	Contents:	functions for extraction of connected pixels from
 *			a pixmap.
 *
 *	Last modify:	11/01/2008
 *
 *%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 */

#ifdef HAVE_CONFIG_H
#include        "config.h"
#endif

#include	<math.h>
#include	<stdio.h>
#include	<stdlib.h>
#include	<string.h>
#include	<time.h>

#include	"define.h"
#include	"globals.h"
#include	"prefs.h"
#include	"back.h"
#include	"check.h"
#include	"clean.h"
#include	"extract.h"
#include	"filter.h"
#include	"image.h"
#include	"plist.h"

#include 	"cuda/cudadetection.h"
#include 	"cuda/cudadeblend.h"
#include	"cuda/cudafilter.h"
#include	"cuda/cudaclean.h"
#include	"cuda/cudaback.h"
#include	"cuda/cudainit.h"
#include	"cuda/cudaanalyse.h"

clock_t start_endobj, end_endobj;
clock_t sum_endobj = 0;

/****************************** scanimage ************************************
PROTO   void scanimage(picstruct *field, picstruct *dfield, picstruct *ffield,
        picstruct *wfield, picstruct *dwfield)
PURPOSE Scan of the large pixmap(s). Main loop and heart of the program.
INPUT   Measurement field pointer,
        Detection field pointer,
        Flag field pointer,
        Measurement weight-map field pointer,
        Detection weight-map field pointer,
OUTPUT  -.
NOTES   -.
AUTHOR  E. Bertin (IAP)
VERSION 11/01/2008
 ***/
void	scanimage(picstruct *field, picstruct **pffield, int nffield)

{
	static infostruct	curpixinfo, *info, *store,
	initinfo, freeinfo, *victim;
	picstruct		*ffield;
	checkstruct		*check;
	objliststruct   objlist;
	objstruct		*cleanobj;
	pliststruct		*pixel, *pixt;
	picstruct		*cfield;

	char			*marker, newmarker, *blankpad, *bpt,*bpt0;
	int			co, i,j, flag, luflag,pstop, xl,xl2,yl, cn,
	nposize, stacksize, w, h, blankh, maxpixnb,
	varthreshflag;
	short	       	trunflag;
	PIXTYPE		thresh, relthresh, cdnewsymbol, cdvar,
	*scan,*dscan,*cdscan,*dwscan,*cdwscan,*cdwscanp,
	*scant, *wscan,*wscanp;
	FLAGTYPE		*pfscan[MAXFLAG];
	status		cs, ps, *psstack;
	int			*start, *end, ymax;

	/* Avoid gcc -Wall warnings */
	scan = dscan = cdscan = cdwscan = cdwscanp = wscan = wscanp = NULL;
	victim = NULL;			/* Avoid gcc -Wall warnings */
	blankh = 0;				/* Avoid gcc -Wall warnings */
	/*----- Beginning of the main loop: Initialisations  */
	thecat.ntotal = thecat.ndetect = 0;

	/* cfield is the detection field in any case */
	cfield = field;

	//thresh_type default is relative.
	//varthreshflag default is false.
	/* If WEIGHTing and no absolute thresholding, activate threshold scaling */
	varthreshflag = 0; //(cdwfield && prefs.thresh_type[0]!=THRESH_ABSOLUTE);

	relthresh = varthreshflag ? prefs.dthresh[0] : 0.0;/* To avoid gcc warnings*/
	w = cfield->width;
	h = cfield->height;
	objlist.dthresh = cfield->dthresh; //dthresh: 270.12
	objlist.thresh = cfield->thresh;   //thresh: 900.40
	cfield->yblank = 1;
	field->y = field->stripy = 0;
	field->ymin = field->stripylim = 0;
	field->stripysclim = 0;

	/**
  if (dfield)
    {
    dfield->y = dfield->stripy = 0;
    dfield->ymin = dfield->stripylim = 0;
    dfield->stripysclim = 0;
    }
  if (nffield)
    for (i=0; i<nffield; i++)
      {
      ffield = pffield[i];
      ffield->y = ffield->stripy = 0;
      ffield->ymin = ffield->stripylim = 0;
      ffield->stripysclim = 0;
      }
  if (wfield)
    {
    wfield->y = wfield->stripy = 0;
    wfield->ymin = wfield->stripylim = 0;
    wfield->stripysclim = 0;
    }
  if (dwfield)
    {
    dwfield->y = dwfield->stripy = 0;
    dwfield->ymin = dwfield->stripylim = 0;
    dwfield->stripysclim = 0;
    } **/

	/*Allocate memory for buffers */
	stacksize = w+1;
	QMALLOC(info, infostruct, stacksize);
	QCALLOC(store, infostruct, stacksize);
	QMALLOC(marker, char, stacksize);
	QMALLOC(dumscan, PIXTYPE, stacksize);
	QMALLOC(psstack, status, stacksize);
	QCALLOC(start, int, stacksize);
	QMALLOC(end, int, stacksize);
	blankpad = bpt = NULL;
	lutzalloc(w,h);
	allocparcelout();
	if (prefs.filter_flag)
	{
		QMALLOC(cdscan, PIXTYPE, stacksize);
		/**
		if (cdwfield)
		{
			QCALLOC(cdwscan, PIXTYPE, stacksize);
			if (PLISTEXIST(wflag))
			{
				QMALLOC(cdwscanp, PIXTYPE, stacksize);
			}
		}**/
		/*-- One needs a buffer to protect filtering if source-blanking applies */
		if (prefs.blank_flag)
		{
			blankh = thefilter->convh/2+1;
			QMALLOC(blankpad, char, w*blankh);
			cfield->yblank -= blankh; //cfield->yblank = -1
			//if (dfield)
			//	field->yblank = cfield->yblank;
			bpt = blankpad;
		}
	}

	/* Some initializations */

	thresh = objlist.dthresh;
	initinfo.pixnb = 0;
	initinfo.flag = 0;
	initinfo.firstpix = initinfo.lastpix = -1;

	for (xl=0; xl<stacksize; xl++)
	{
		marker[xl]  = 0 ;
		dumscan[xl] = -BIG ;
	}

	co = pstop = 0;
	objlist.nobj = 1;
	curpixinfo.pixnb = 1;

	/* Init cleaning procedure */
	initclean();

	/*----- Allocate memory for the pixel list */
	init_plist();

	if (!(pixel = objlist.plist = (pliststruct*)malloc(nposize=prefs.mem_pixstack*plistsize)))
		error(EXIT_FAILURE, "Not enough memory to store the pixel stack:\n",
				"           Try to decrease MEMORY_PIXSTACK");

	/*----- at the beginning, "free" object fills the whole pixel list */
	freeinfo.firstpix = 0;
	freeinfo.lastpix = nposize-plistsize;
	pixt = pixel;
	for (i=plistsize; i<nposize; i += plistsize, pixt += plistsize)
		PLIST(pixt, nextpix) = i;
	PLIST(pixt, nextpix) = -1;

	//added by zhaobaoxue
	//loadstrip(field);

	//init_device(field->width, field->height);
	init_detection();

	//here(before convolution, the two field strips are the same

	if(thefilter->convw != thefilter->convh)
		printf("convolution mask is not square, not supported by the current kernel");

	cudaFilter(thefilter->conv, thefilter->convw);

	size_t numValidObj;
	size_t numValidPix;
	int numdetected;

	run_detection(objlist.dthresh, objlist.thresh, &numValidObj, &numValidPix);

	init_deblend(objlist.dthresh, 32, numValidObj, numValidPix);
	numdetected = parcel_out(objlist.dthresh, 32, prefs.deb_maxarea,
			numValidObj, numValidPix, prefs.deblend_mincont);
	clear_deblend(32);

	printf("%d object detected\n", numdetected);

	printf("flagobj.peakx is %d \n", flagobj.peakx);

	analyse_gpu(
			flagobj.poserr_mx2,
			flagobj.peakx,
			flagobj.iso[0],
			flagobj.fwhm,
			field->backsig,
			field->gain,
			field->ngamma,
			field->thresh,
			field->dthresh,
			field->satur_level,
			plistexist_var,
			plistoff_var,
			prefs.weightgain_flag,
			prefs.ext_minarea,
			prefs.clean_flag,
			prefs.detect_type,
			field->nbackx,
			field->nbacky,
			field->backw,
			field->backh,
			field->width,
			numdetected);

	unsigned int *masterIndex = (unsigned int*)malloc(numdetected*sizeof(unsigned int));

	run_clean(masterIndex, prefs.clean_param, numdetected);

	objstruct *objectlist = (objstruct*)malloc(numdetected*sizeof(objstruct));

	int total = numdetected;

	unsigned int *h_index = (unsigned int*)malloc(total*sizeof(unsigned int));
	unsigned int *h_flag = (unsigned int*)malloc(total*sizeof(unsigned int));
	unsigned int *h_fdnpix = (unsigned int*)malloc(total*sizeof(unsigned int));
	float 		 *h_dthresh = (float*)malloc(total*sizeof(float));

	unsigned int *h_xmin  = (unsigned int*)malloc(total*sizeof(unsigned int));
	unsigned int *h_xmax  = (unsigned int*)malloc(total*sizeof(unsigned int));
	unsigned int *h_ymin  = (unsigned int*)malloc(total*sizeof(unsigned int));
	unsigned int *h_ymax  = (unsigned int*)malloc(total*sizeof(unsigned int));
	unsigned int *h_dnpix = (unsigned int*)malloc(total*sizeof(unsigned int));
	unsigned int *h_npix  = (unsigned int*)malloc(total*sizeof(unsigned int));
	unsigned int *h_peakx = (unsigned int*)malloc(total*sizeof(unsigned int));
	unsigned int *h_peaky = (unsigned int*)malloc(total*sizeof(unsigned int));

	float 	*h_bkg  = (float*)malloc(total*sizeof(float));
	float 	*h_dbkg  = (float*)malloc(total*sizeof(float));
	float	*h_sigbkg  = (float*)malloc(total*sizeof(float));
	float 	*h_a  = (float*)malloc(total*sizeof(float));
	float 	*h_b  = (float*)malloc(total*sizeof(float));
	float 	*h_cxx  = (float*)malloc(total*sizeof(float));
	float 	*h_cxy  = (float*)malloc(total*sizeof(float));
	float 	*h_cyy  = (float*)malloc(total*sizeof(float));
	float 	*h_theta  = (float*)malloc(total*sizeof(float));
	float 	*h_abcor  = (float*)malloc(total*sizeof(float));
	float	*h_peak  = (float*)malloc(total*sizeof(float));
	float 	*h_dpeak  = (float*)malloc(total*sizeof(float));
	float 	*h_fdpeak  = (float*)malloc(total*sizeof(float));
	float	*h_flux  = (float*)malloc(total*sizeof(float));
	float 	*h_dflux = (float*)malloc(total*sizeof(float));
	float 	*h_fdflux  = (float*)malloc(total*sizeof(float));
	float	*h_fluxerr = (float*)malloc(total*sizeof(float));
	float	*h_thresh  = (float*)malloc(total*sizeof(float));
	float	*h_mthresh  = (float*)malloc(total*sizeof(float));
	float	*h_fwhm  = (float*)malloc(total*sizeof(float));

	double 	*h_mx   = (double*)malloc(total*sizeof(double));
	double 	*h_my   = (double*)malloc(total*sizeof(double));
	double 	*h_mx2   = (double*)malloc(total*sizeof(double));
	double 	*h_my2   = (double*)malloc(total*sizeof(double));
	double 	*h_mxy   = (double*)malloc(total*sizeof(double));
	double	*h_poserr_mx2   = (double*)malloc(total*sizeof(double));
	double	*h_poserr_my2   = (double*)malloc(total*sizeof(double));
	double	*h_poserr_mxy   = (double*)malloc(total*sizeof(double));
	char  	*h_singuflag   = (char*)malloc(total*sizeof(char));
	int		*h_iso[NISO];

	for(i=0; i<NISO; i++)
		h_iso[i] = (int*)malloc(total*sizeof(int));

	copyobjects(
			h_index,
			h_flag,
			h_fdnpix,
			h_dthresh,
			h_xmin,
			h_xmax,
			h_ymin ,
			h_ymax,
			h_dnpix,
			h_npix,
			h_peakx,
			h_peaky ,

			h_bkg,
			h_dbkg ,
			h_sigbkg,
			h_a,
			h_b,
			h_cxx,
			h_cxy,
			h_cyy,
			h_theta,
			h_abcor,
			h_peak,
			h_dpeak,
			h_fdpeak ,
			h_flux ,
			h_dflux,
			h_fdflux,
			h_fluxerr,
			h_thresh,
			h_mthresh,
			h_fwhm,
			h_mx,
			h_my,
			h_mx2,
			h_my2,
			h_mxy,
			h_poserr_mx2 ,
			h_poserr_my2,
			h_poserr_mxy,
			h_singuflag,
			h_iso,
			total);

	clear_detection();
	clear_device(field->strip);


	int idx, t, mindex, preindex;

	start_endobj = clock();

	for(idx=0; idx<total; idx++)
	{
		objstruct* obj = objectlist+idx;

		obj->number = h_index[idx];
		obj->flag = h_flag[idx];
		obj->fdnpix = h_fdnpix[idx]; //v

		//if(idx < 10)
		//	printf("distance is %d\n", obj->fdnpix);

		obj->dthresh = h_dthresh[idx]; //v
		obj->xmin = h_xmin[idx]; //v
		obj->xmax = h_xmax[idx]; //v
		obj->ymin = h_ymin[idx]; //v
		obj->ymax = h_ymax[idx]; //v
		obj->dnpix = h_dnpix[idx]; //v
		obj->npix = h_npix[idx]; //v
		obj->peakx = h_peakx[idx]; //v
		obj->peaky = h_peaky[idx]; //v

		obj->bkg = h_bkg[idx]; //v
		obj->dbkg = h_dbkg[idx]; //v
		obj->sigbkg = h_sigbkg[idx]; //v
		obj->a = h_a[idx]; //v
		obj->b = h_b[idx]; //v
		obj->cxx = h_cxx[idx]; //v
		obj->cxy = h_cxy[idx]; //v
		obj->cyy = h_cyy[idx]; //v
		obj->theta = h_theta[idx];
		obj->abcor = h_abcor[idx];
		obj->peak = h_peak[idx];
		obj->dpeak = h_dpeak[idx];
		obj->fdpeak = h_fdpeak[idx];
		obj->flux = h_flux[idx];
		obj->dflux = h_dflux[idx];
		obj->fdflux = h_fdflux[idx];
		obj->fluxerr = h_fluxerr[idx];
		obj->thresh = h_thresh[idx];
		obj->mthresh = h_mthresh[idx];
		obj->fwhm = h_fwhm[idx];

		obj->mx =h_mx[idx];
		obj->my = h_my[idx];
		obj->mx2 = h_mx2[idx];
		obj->my2 = h_my2[idx];
		obj->mxy = h_mxy[idx];
		obj->poserr_mx2 = h_poserr_mx2[idx];
		obj->poserr_my2 = h_poserr_my2[idx];
		obj->poserr_mxy = h_poserr_mxy[idx];
		obj->singuflag = h_singuflag[idx];

		for(t=0; t<NISO; t++)
			obj->iso[t] = h_iso[t][idx];
	}

	printf("objectlist[1] %f, %d \n", objectlist[1].flux, objectlist[1].fdnpix);
	//mergeobject, pasteimage

	//takes only 0.01s
	for(idx = 0; idx<numdetected; idx++)
	{
		preindex = -1;
		mindex = idx;
		//decide if the current obj should be merged to its master obj
		while((mindex = masterIndex[mindex]) != -1)
		{
			preindex = mindex;
		}

		if(preindex != -1)
		{
			//mergeobject(objectlist + idx, objectlist + preindex);

			/*
			if (prefs.blank_flag)
			{
				//---------- Paste back ``CLEANed'' object pixels before forgetting them
				if ((globallist.obj+idx)->blank)
				{
					pasteimage(field, (globallist.obj+idx)->blank,
							(globallist.obj+idx)->subw,
							(globallist.obj+idx)->subh,
							(globallist.obj+idx)->subx,
							(globallist.obj+idx)->suby);
					free((globallist.obj+idx)->blank);
				}
				//dbland is not handled here
			}*/
		}
	}

	//final process and output objects,
	//0.57s without output, 1.93s with output
	for(idx = 0; idx<numdetected; idx++)
	{

		//if((int)masterIndex[idx] == -1) {
			endobject(field, NULL, NULL, NULL, objectlist+idx);
		//}
	}

	end_endobj = clock();
	printf("total time consumed by merge and end obj is %f\n", (end_endobj-start_endobj+0.0)/CLOCKS_PER_SEC);

	///////////////////////////////////////////////////////
	/*----- Here we go */
	for (yl=0; yl<=h;)
	{
		ps = COMPLETE;
		cs = NONOBJECT;
		if (yl==h)
		{
			/*---- Need an empty line for Lutz' algorithm to end gracely */
			if (prefs.filter_flag)
			{
				free(cdscan);
				/**if (cdwfield)
				{
					free(cdwscan);
					if (PLISTEXIST(wflag))
						free(cdwscanp);
				}*/
			}
			cdwscan = cdwscanp = cdscan = dumscan;
		}
		else
		{
			wscan = NULL;
			dwscan = wscan;
			dscan = scan;

			if (prefs.filter_flag)
			{
				filter(cfield, cdscan);
			}
			else
			{
				cdscan = dscan;
				cdwscan = dwscan;
			}

			if ((check=prefs.check[CHECK_FILTERED]))
				writecheck(check, cdscan, w);
		}

		//cdscan stores the current row.
		//cdnewsymbol stores the current pixel
		
		/**
		trunflag = (yl==0 || yl==h-1)? OBJ_TRUNC:0;
		for (xl=0; xl<=w; xl++)
		{
			if (xl == w)
				cdnewsymbol = -BIG;
			else
				cdnewsymbol = cdscan[xl];

			newmarker = marker[xl];
			marker[xl] = 0;

			curpixinfo.flag = trunflag;
			if (varthreshflag)
				thresh = relthresh*sqrt(cdvar = ((xl==w || yl==h)? 0.0:cdwscan[xl]));
			luflag = cdnewsymbol > thresh?1:0;

			if (luflag)
			{
				if (xl==0 || xl==w-1)
					curpixinfo.flag |= OBJ_TRUNC;
				pixt = pixel + (cn=freeinfo.firstpix);
				freeinfo.firstpix = PLIST(pixt, nextpix);

				//------- Running out of pixels, the largest object becomes a "victim" ------

				if (freeinfo.firstpix==freeinfo.lastpix)
				{
					sprintf(gstr, "%d,%d", xl+1, yl+1);
					warning("Pixel stack overflow at position ", gstr);
					maxpixnb = 0;
					for (i=0; i<=w; i++)
						if (store[i].pixnb>maxpixnb)
							if (marker[i]=='S' || (newmarker=='S' && i==xl))
							{
								flag = 0;
								if (i<xl)
									for (j=0; j<=co; j++)
										flag |= (start[j]==i);
								if (!flag)
									maxpixnb = (victim = &store[i])->pixnb;
							}
					for (j=1; j<=co; j++)
						if (info[j].pixnb>maxpixnb)
							maxpixnb = (victim = &info[j])->pixnb;

					if (!maxpixnb)
						error(EXIT_FAILURE, "*Fatal Error*: something is badly bugged in ",
								"scanimage()!");
					if (maxpixnb <= 1)
						error(EXIT_FAILURE, "Pixel stack overflow in ", "scanimage()");
					freeinfo.firstpix = PLIST(pixel+victim->firstpix, nextpix);
					PLIST(pixel+victim->lastpix, nextpix) = freeinfo.lastpix;
					PLIST(pixel+(victim->lastpix=victim->firstpix), nextpix) = -1;
					victim->pixnb = 1;
					victim->flag |= OBJ_OVERFLOW;
				}

				//---------------------------------------------------------------------------
				curpixinfo.lastpix = curpixinfo.firstpix = cn;
				PLIST(pixt, nextpix) = -1;
				PLIST(pixt, x) = xl;
				PLIST(pixt, y) = yl;
				PLIST(pixt, value) = scan[xl];
				if (PLISTEXIST(dvalue))
					PLISTPIX(pixt, dvalue) = dscan[xl];
				if (PLISTEXIST(cdvalue))
					PLISTPIX(pixt, cdvalue) = cdnewsymbol;
				if (PLISTEXIST(flag))
					for (i=0; i<nffield; i++)
						PLISTFLAG(pixt, flag[i]) = pfscan[i][xl];
				if (PLISTEXIST(wflag) && wscan)
				{
					PLISTFLAG(pixt, wflag) = 0;
					if (xl>0)
					{
						if (wscan[xl-1] >= BIG)
							PLISTFLAG(pixt, wflag) |= OBJ_WEIGHTZERO;
						if (cdwscan[xl-1] >= BIG)
							PLISTFLAG(pixt, wflag) = OBJ_DWEIGHTZERO;
					}
					PLISTFLAG(pixt, wflag) = 0;
					if (xl<w-1)
					{
						if (wscan[xl+1] >= BIG)
							PLISTFLAG(pixt, wflag) |= OBJ_WEIGHTZERO;
						if (cdwscan[xl+1] >= BIG)
							PLISTFLAG(pixt, wflag) = OBJ_DWEIGHTZERO;
					}
					if (yl>0)
					{
						if (wscanp[xl] >= BIG)
							PLISTFLAG(pixt, wflag) |= OBJ_WEIGHTZERO;
						if (cdwscanp[xl] >= BIG)
							PLISTFLAG(pixt, wflag) = OBJ_DWEIGHTZERO;
					}
				}
				if (PLISTEXIST(dthresh))
					PLISTPIX(pixt, dthresh) = thresh;
				if (PLISTEXIST(var))
					PLISTPIX(pixt, var) = wscan[xl];

				if (cs != OBJECT)
					//------------------------------- Start Segment -----------------------------

					{
					cs = OBJECT;
					if (ps == OBJECT)
					{
						if (start[co] == UNKNOWN)
						{
							marker[xl] = 'S';
							start[co] = xl;
						}
						else
							marker[xl] = 's';
					}
					else
					{
						psstack[pstop++] = ps;
						marker[xl] = 'S';
						start[++co] = xl;
						ps = COMPLETE;
						info[co] = initinfo;
					}
					}

				//---------------------------------------------------------------------------
			}

			if (newmarker)

				//---------------------------- Process New Marker ---------------------------

			{
				if (newmarker == 'S')
				{
					psstack[pstop++] = ps;
					if (cs == NONOBJECT)
					{
						psstack[pstop++] = COMPLETE;
						info[++co] = store[xl];
						start[co] = UNKNOWN;
					}
					else
						update (&info[co],&store[xl], pixel);
					ps = OBJECT;
				}
				else if (newmarker == 's')
				{
					if ((cs == OBJECT) && (ps == COMPLETE))
					{
						pstop--;
						xl2 = start[co];
						update (&info[co-1],&info[co], pixel);
						if (start[--co] == UNKNOWN)
							start[co] = xl2;
						else
							marker[xl2] = 's';
					}
					ps = OBJECT;
				}
				else if (newmarker == 'f')
					ps = INCOMPLETE;
				else if (newmarker == 'F')
				{
					ps = psstack[--pstop];
					if ((cs == NONOBJECT) && (ps == COMPLETE))
					{
						if (start[co] == UNKNOWN)
						{
							if ((int)info[co].pixnb >= prefs.ext_minarea)
							{
								sortit(field, dfield, wfield, cdwfield, &info[co], &objlist,
										cdwscan, wscan);
							}
							// ------------------------------------ free the chain-list 

							PLIST(pixel+info[co].lastpix, nextpix) = freeinfo.firstpix;
							freeinfo.firstpix = info[co].firstpix;
						}
						else
						{
							marker[end[co]] = 'F';
							store[start[co]] = info[co];
						}
						co--;
						ps = psstack[--pstop];
					}
				}
			}
			//---------------------------------------------------------------------------

			if (luflag)
				update (&info[co],&curpixinfo, pixel);
			else
			{
				if (cs == OBJECT)
					//-------------------------------- End Segment ------------------------------
				{
					cs = NONOBJECT;
					if (ps != COMPLETE)
					{
						marker[xl] = 'f';
						end[co] = xl;
					}
					else
					{
						ps = psstack[--pstop];
						marker[xl] = 'F';
						store[start[co]] = info[co];
						co--;
					}
				}
			}

			if (prefs.blank_flag && xl<w)
			{
				if (prefs.filter_flag)
					*(bpt++) = (luflag)?1:0;
				else if (luflag)
					dscan[xl] = -BIG;
				if (dfield && luflag)
					scan[xl] = -BIG;
			}
			//--------------------- End of the loop over the x's -----------------------
		}

		/* Detected pixel removal at the end of each line */
		//I don't understand
		if (prefs.blank_flag && yl<h)
		{
			if (prefs.filter_flag)
			{
				bpt = bpt0 = blankpad + w*((yl+1)%blankh);
				if (cfield->yblank >= 0)
				{
					scant = &PIX(cfield, 0, cfield->yblank);
					for (i=w; i--; scant++)
						if (*(bpt++))
							*scant = -BIG;
					/*
					if (dfield)
					{
						bpt = bpt0;
						scant = &PIX(field, 0, cfield->yblank);
						for (i=w; i--; scant++)
							if (*(bpt++))
								*scant = -BIG;
					}*/
					bpt = bpt0;
				}
			}
			cfield->yblank++;
			/*
			if (dfield)
				field->yblank = cfield->yblank; */
		}

		/*-- Prepare markers for the next line */
		yl++;
		field->stripy = (field->y=yl)%field->stripheight;
		/**
		if (dfield)
			dfield->stripy = (dfield->y=yl)%dfield->stripheight;
		if (nffield)
			for (i=0; i<nffield; i++)
			{
				ffield = pffield[i];
				ffield->stripy = (ffield->y=yl)%ffield->stripheight;
			}
		if (wfield)
			wfield->stripy = (wfield->y=yl)%wfield->stripheight;
		if (dwfield)
			dwfield->stripy = (dwfield->y=yl)%dwfield->stripheight;

		//-- Remove objects close to the ymin limit if ymin is ready to increase 
		if (cfield->stripy==cfield->stripysclim)
		{
			cleanobj = cleanobjlist->obj+cleanobjlist->nobj-1;
			for (i=cleanobjlist->nobj; i--; cleanobj--)
			{
				if (cleanobj->ycmin <= cfield->ymin)
				{
					//-------- Warn if there is a possibility for any aperture to be truncated
					if ((ymax=cleanobj->ycmax) > cfield->ymax)
					{
						sprintf(gstr, "Object at position %.0f,%.0f ",
								cleanobj->mx+1, cleanobj->my+1);
						QWARNING(gstr, "may have some apertures truncated:\n"
								"          You might want to increase MEMORY_BUFSIZE");
					}
					else if (ymax>cfield->yblank && prefs.blank_flag)
					{
						sprintf(gstr, "Object at position %.0f,%.0f ",
								cleanobj->mx+1, cleanobj->my+1);
						QWARNING(gstr, "may have some unBLANKed neighbours:\n"
								"          You might want to increase MEMORY_PIXSTACK");
					}
					endobject(field, dfield, wfield, cdwfield, i, cleanobjlist);
					subcleanobj(i);
					cleanobj = cleanobjlist->obj+i;	// realloc in subcleanobj()
				}
			}
		}

		if (!((yl+1)%16))
			NPRINTF(OUTPUT, "\33[1M> Line:%5d  "
					"Objects: %8d detected / %8d sextracted\n\33[1A",
					yl+1, thecat.ndetect, thecat.ntotal);
		/*--------------------- End of the loop over the y's -----------------------*/
	}

	//printf("time consumed by filter is %f\n", (sum_filter_loop+0.0)/CLOCKS_PER_SEC);

	/** Removal or the remaining pixels 
	if (prefs.blank_flag && prefs.filter_flag && (cfield->yblank >= 0))
		for (j=blankh-1; j--; yl++)
		{
			bpt = bpt0 = blankpad + w*(yl%blankh);
			scant = &PIX(cfield, 0, cfield->yblank);
			for (i=w; i--; scant++)
				if (*(bpt++))
					*scant = -BIG;
			if (dfield)
			{
				bpt = bpt0;
				scant = &PIX(field, 0, cfield->yblank);
				for (i=w; i--; scant++)
					if (*(bpt++))
						*scant = -BIG;
			}
			cfield->yblank++;
			if (dfield)
				field->yblank = cfield->yblank;
		}

	// Now that all "detected" pixels have been removed, analyse detections
	for (j=cleanobjlist->nobj; j--;)
	{
		endobject(field, dfield, wfield, cdwfield, 0, cleanobjlist);
		subcleanobj(0);
	}**/

	endclean();

	/*Free memory */
	freeparcelout();
	free(pixel);
	lutzfree();
	free(info);
	free(store);
	free(marker);
	free(dumscan);
	free(psstack);
	free(start);
	free(end);
	if (prefs.blank_flag && prefs.filter_flag)
		free(blankpad);


	////////////////added by zhaobaoxue for clean

//	merge_start = clock();
//

//
//
//	merge_sum += (merge_end - merge_start);
//	printf("time consumed by merge and output is %f\n", (merge_sum+0.0)/CLOCKS_PER_SEC);
//
//	/*
//	FILE *pfile;
//	pfile = fopen("/home/zhao/gwac/demo/test.txt","a");
//
//	if(pfile == NULL)
//		perror("Error opening file\n");
//	int *testdata = (int*)malloc(100*1024*1024*sizeof(int));
//	fwrite(testdata, sizeof(testdata[0]), 100*1024*1024, pfile);
//	fclose(pfile);*/
//
//	free(masterIndex);
//
//	free(globallist.plist);
//	free(globallist.obj);

	////////////////

	return;
}


/********************************* update ************************************/
/*
update object's properties each time one of its pixels is scanned by lutz()
 */
void  update(infostruct *infoptr1, infostruct *infoptr2, pliststruct *pixel)

{
	infoptr1->pixnb += infoptr2->pixnb;
	infoptr1->flag |= infoptr2->flag;
	if (infoptr1->firstpix == -1)
	{
		infoptr1->firstpix = infoptr2->firstpix;
		infoptr1->lastpix = infoptr2->lastpix;
	}
	else if (infoptr2->lastpix != -1)
	{
		PLIST(pixel+infoptr1->lastpix, nextpix) = infoptr2->firstpix;
		infoptr1->lastpix = infoptr2->lastpix;
	}

	return;
}

/********************************* sortit ************************************/
/*
build the object structure.
 */
void  sortit(picstruct *field, picstruct *dfield, picstruct *wfield,
		picstruct *dwfield, infostruct *info, objliststruct *objlist,
		PIXTYPE *cdwscan, PIXTYPE *wscan)

{
	picstruct		*cfield;
	objliststruct	objlistout, *objlist2;
	static objstruct	obj;
	objstruct		*cobj;
	pliststruct		*pixel;
	int 			i,j,n;

	cfield = dfield? dfield: field;

	pixel = objlist->plist;
	objlistout.obj = NULL;
	objlistout.plist = NULL;
	objlistout.nobj = objlistout.npix = 0;

	/*----- Allocate memory to store object data */

	objlist->obj = &obj;
	objlist->nobj = 1;

	memset(&obj, 0, (size_t)sizeof(objstruct));
	objlist->npix = info->pixnb;
	obj.firstpix = info->firstpix;
	obj.lastpix = info->lastpix;
	obj.flag = info->flag;
	obj.dthresh = objlist->dthresh;
	obj.thresh = objlist->thresh;

	preanalyse(0, objlist, ANALYSE_FAST);

	/*----- Check if the current strip contains the lower isophote... */
	if ((int)obj.ymin < cfield->ymin)
		obj.flag |= OBJ_ISO_PB;

	if (!(obj.flag & OBJ_OVERFLOW) && (createsubmap(objlist, 0) == RETURN_OK))
	{
		int t = parcelout(objlist, &objlistout);
		if (t == RETURN_OK)
			objlist2 = &objlistout;
		else
		{
			objlist2 = objlist;
			for (i=0; i<objlist2->nobj; i++)
				objlist2->obj[i].flag |= OBJ_DOVERFLOW;
			sprintf(gstr, "%.0f,%.0f", obj.mx+1, obj.my+1);
			warning("Deblending overflow for detection at ", gstr);
		}
		free(obj.submap);
	}
	else
		objlist2 = objlist;

	for (i=0; i<objlist2->nobj; i++)
	{
		preanalyse(i, objlist2, ANALYSE_FULL|ANALYSE_ROBUST);
		analyse(field, dfield, i, objlist2);
		cobj = objlist2->obj + i;
		
		//the following one if block takes only 0.16s for 4kx4k image.
		if (prefs.blank_flag)
		{
			if (createblank(objlist2,i) != RETURN_OK)
			{
				/*------ Not enough mem. for the BLANK vignet: flag the object now */
				cobj->flag |= OBJ_OVERFLOW;
				cobj->blank = cobj->dblank = NULL;
				sprintf(gstr, "%.0f,%.0f", cobj->mx+1, cobj->my+1);
				warning("Memory overflow during masking for detection at ", gstr);
			}
		}

		if ((n=cleanobjlist->nobj) >= prefs.clean_stacksize)
		{
			objstruct	*cleanobj;
			int		ymin, ymax, victim=0;

			ymin = 2000000000;	/* No image is expected to be that tall ! */
			cleanobj = cleanobjlist->obj;
			
			for (j=0; j<n; j++, cleanobj++) //the following for-block takes about 2.4s
				if (cleanobj->ycmax < ymin)
				{
					victim = j;
					ymin = cleanobj->ycmax;
				}

			//the following if block takes only 0.06s for 4k image
			/*---- Warn if there is a possibility for any aperture to be truncated */
			if (field->ymax < field->height)
			{
				cleanobj = &cleanobjlist->obj[victim];
				if ((ymax=cleanobj->ycmax) > field->ymax)
				{
					sprintf(gstr, "Object at position %.0f,%.0f ",
							cleanobj->mx+1, cleanobj->my+1);
					QWARNING(gstr, "may have some apertures truncated:\n"
							"          You might want to increase MEMORY_OBJSTACK");
				}
				else if (ymax>field->yblank && prefs.blank_flag)
				{
					sprintf(gstr, "Object at position %.0f,%.0f ",
							cleanobj->mx+1, cleanobj->my+1);
					QWARNING(gstr, "may have some unBLANKed neighbours\n"
							"          You might want to increase MEMORY_OBJSTACK");
				}
			}

			endobject(field, dfield, wfield, dwfield, cleanobjlist->obj+victim);
			subcleanobj(victim);
		}

		/* Only add the object if it is not swallowed by cleaning */
		if (!prefs.clean_flag || clean(field, dfield, i, objlist2))
			addcleanobj(cobj);
	}

	free(objlistout.plist);
	free(objlistout.obj);

	return;
}


/******************************** preanalyse *********************************
PROTO   void preanalyse(int no, objliststruct *objlist, int analyse_type)
PURPOSE Compute basic image parameters from the pixel-list for each detection.
INPUT   objlist number,
        objlist pointer,
        analysis switch flag.
OUTPUT  -.
NOTES   -.
AUTHOR  E. Bertin (IAP & Leiden & ESO)
VERSION 28/11/2003
 ***/
void  preanalyse(int no, objliststruct *objlist, int analyse_type)

{
	objstruct	*obj = &objlist->obj[no];
	pliststruct	*pixel = objlist->plist, *pixt;
	PIXTYPE	peak, cpeak, val, cval, minthresh, thresht;
	double	thresh,thresh2, t1t2,darea,
	mx,my, mx2,my2,mxy, rv, tv,
	xm,ym, xm2,ym2,xym,
	temp,temp2, theta,pmx2,pmy2;
	int		x, y, xmin,xmax, ymin,ymax,area2, fdnpix, dnpix;


	/*-----  initialize stacks and bounds */
	thresh = obj->dthresh;
	if (PLISTEXIST(dthresh))
		minthresh = BIG;
	else
		minthresh = 0.0;
	fdnpix = dnpix = 0;
	rv = 0.0;
	peak = cpeak = -BIG;
	ymin = xmin = 2*MAXPICSIZE;    /* to be really sure!! */
	ymax = xmax = 0;

	/*-----  integrate results */
	for (pixt=pixel+obj->firstpix; pixt>=pixel; pixt=pixel+PLIST(pixt,nextpix))
	{
		x = PLIST(pixt, x);
		y = PLIST(pixt, y);
		val=PLISTPIX(pixt, dvalue);
		if (cpeak < (cval=PLISTPIX(pixt, cdvalue)))
			cpeak = cval;
		if (PLISTEXIST(dthresh) && (thresht=PLISTPIX(pixt, dthresh))<minthresh)
			minthresh = thresht;
		if (peak < val)
			peak = val;
		rv += cval;
		if (xmin > x)
			xmin = x;
		if (xmax < x)
			xmax = x;
		if (ymin > y)
			ymin = y;
		if (ymax < y)
			ymax = y;
		fdnpix++;
	}

	if (PLISTEXIST(dthresh))
		obj->dthresh = thresh = minthresh;

	/* copy some data to "obj" structure */

	obj->fdnpix = (LONG)fdnpix;
	obj->fdflux = (float)rv;
	obj->fdpeak = cpeak;
	obj->dpeak = peak;
	obj->xmin = xmin;
	obj->xmax = xmax;
	obj->ymin = ymin;
	obj->ymax = ymax;

	if (analyse_type & ANALYSE_FULL)
	{
		mx = my = tv = 0.0;
		mx2 = my2 = mxy = 0.0;
		thresh2 = (thresh + peak)/2.0;
		area2 = 0;
		for (pixt=pixel+obj->firstpix; pixt>=pixel; pixt=pixel+PLIST(pixt,nextpix))
		{
			x = PLIST(pixt,x)-xmin;	/* avoid roundoff errors on big images */
			y = PLIST(pixt,y)-ymin;	/* avoid roundoff errors on big images */
			cval = PLISTPIX(pixt, cdvalue);
			tv += (val = PLISTPIX(pixt, dvalue));
			if (val>thresh)
				dnpix++;
			if (val > thresh2)
				area2++;
			mx += cval * x;
			my += cval * y;
			mx2 += cval * x*x;
			my2 += cval * y*y;
			mxy += cval * x*y;
		}

		/*----- compute object's properties */
		xm = mx / rv;			/* mean x */
		ym = my / rv;			/* mean y */

		/*-- In case of blending, use previous barycenters */
		if ((analyse_type&ANALYSE_ROBUST) && (obj->flag&OBJ_MERGED))
		{
			double	xn,yn;

			xn = obj->mx-xmin;
			yn = obj->my-ymin;
			xm2 = mx2 / rv + xn*xn - 2*xm*xn;
			ym2 = my2 / rv + yn*yn - 2*ym*yn;
			xym = mxy / rv + xn*yn - xm*yn - xn*ym;
			xm = xn;
			ym = yn;
		}
		else
		{
			xm2 = mx2 / rv - xm * xm;	/* variance of x */
			ym2 = my2 / rv - ym * ym;	/* variance of y */
			xym = mxy / rv - xm * ym;	/* covariance */
		}

		/* Handle fully correlated x/y (which cause a singularity...) */
		if ((temp2=xm2*ym2-xym*xym)<0.00694)
		{
			xm2 += 0.0833333;
			ym2 += 0.0833333;
			temp2 = xm2*ym2-xym*xym;
			obj->singuflag = 1;
		}
		else
			obj->singuflag = 0;

		if ((fabs(temp=xm2-ym2)) > 0.0)
			theta = atan2(2.0 * xym,temp) / 2.0;
		else
			theta = PI/4.0;

		temp = sqrt(0.25*temp*temp+xym*xym);
		pmy2 = pmx2 = 0.5*(xm2+ym2);
		pmx2+=temp;
		pmy2-=temp;

		obj->dnpix = (obj->flag & OBJ_OVERFLOW)? obj->fdnpix:(LONG)dnpix;
		obj->dflux = tv;
		obj->mx = xm+xmin;	/* add back xmin */
		obj->my = ym+ymin;	/* add back ymin */
		obj->mx2 = xm2;
		obj->my2 = ym2;
		obj->mxy = xym;
		obj->a = (float)sqrt(pmx2);
		obj->b = (float)sqrt(pmy2);
		obj->theta = theta*180.0/PI;

		obj->cxx = (float)(ym2/temp2);
		obj->cyy = (float)(xm2/temp2);
		obj->cxy = (float)(-2*xym/temp2);

		darea = (double)area2 - dnpix;
		t1t2 = thresh/thresh2;
		if (t1t2>0.0 && !prefs.dweight_flag)
		{
			obj->abcor = (darea<0.0?darea:-1.0)/(2*PI*log(t1t2<1.0?t1t2:0.99)
			*obj->a*obj->b);
			if (obj->abcor>1.0)
				obj->abcor = 1.0;
		}
		else
			obj->abcor = 1.0;
	}

	return;
}

